---
title: 微服务/OpenTelemetry
date: 2021-03-07 21:57:31
tags: 微服务
---

# 微服务/分布式系统观测

微服务越来越多，rpc调用越来越复杂。

一方面，如果某个环节出错，最前端的服务可能只是提示了一句轻飘飘的“系统开小差了”，具体的错误信息，可能早就淹没在无穷无尽、格式驳杂的后台日志中了。

另一方面，复杂的调用关系带来了尴尬的协作问题。参与的服务越多，依赖关系越复杂。节假日来临，最前端的服务做出了“xxx请求将暴涨”的预测，但是完全不知道哪个后端服务是瓶颈所在，无法提前做出精准警示。

再一方面，系统的协作比以往更加紧密，我们更需要挑出一些关键节点进行监控，比如：“核心db的访问延迟情况”、“首页推荐的缓存命中率”、“xxx页面的在线人数”、“视频上传成功数量”。

这三点被称为：logging、tracing、metrics。也有一个更加统一的名词：[open telemetry](https://opentelemetry.io/docs/)

## 贯穿整个链路的概念：Tracing (Span)

每个调用节点，可以归纳为一个Span。具有自身的服务接口名、下游服务的服务接口名、自身服务的开始/完成时间、下游服务的开始/完成时间、自身节点id、链路调用id、返回错误码等关键属性。

根据每个节点的Span，可以计算出调用整个链路的依赖关系、节点耗时、调用结果等特征。于是我们完成了调用链路的追踪：“tracing”。

几乎所有的open telemetry系统，都会基于tracing搞出一个很好看的链路可视化图表。

如果加上用户id、视频id等属性，就可以刻画出一个用户/视频的调用链路，包括耗时、依赖关系、调用结果等。

这个范畴应该属于opentracing。

## 更加详细的数据： Logging

## 关键指标的监控： Metrics

## 数据的收集通道：Collector

[Data Collection](https://opentelemetry.io/docs/concepts/data-collection/)

各节点的属性需要汇总到一个统一的数据中心，用于查询、监控、报警。

这样的数据收集系统应该很容易实现：要么部署一个agent，要么提供统一接入接口。各语言的API自己实现异步的上报-收集逻辑即可。

难点在于后续的数据存储，需要支持冷热分离、业务隔离、复杂计算、全局搜索等重要的特性。

## 方便可用的demo教程

不得不说，docker万岁。照着 [jaeger tracing](https://www.jaegertracing.io/docs/1.22/getting-started/)，很快就可以完成链路调用的可视化。

```bash
 docker run -d --name jaeger   -e COLLECTOR_ZIPKIN_HTTP_PORT=9411   -p 5775:5775/udp   -p 6831:6831/udp   -p 6832:6832/udp   -p 5778:5778   -p 16686:16686   -p 14268:14268   -p 14250:14250   -p 9411:9411   jaegertracing/all-in-one:1.22
```

```golang
package main

import (
	"context"
	"github.com/davecgh/go-spew/spew"
	"github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/log"
	"github.com/uber/jaeger-client-go"
	"github.com/uber/jaeger-client-go/config"
	"time"
)

func busyness(ctx context.Context, count int64) {
	span, ctx := opentracing.StartSpanFromContext(ctx, spew.Sprint("demo/step%v", count))
	defer span.Finish()
	span.LogFields(log.String("msg", spew.Sprintf("busyness %v", count)))
	time.Sleep(time.Millisecond * time.Duration(count) * 100)
	if count == 0 {
		return
	}
	busyness(ctx, count-1)
}

func main() {

	tracer, closer, err := config.Configuration{
		ServiceName: "daydreamstest",
	}.NewTracer(
		config.Sampler(jaeger.NewConstSampler(true)), // 采样策略
	)
	if err != nil {
		panic(err)
	}
	defer closer.Close()
	opentracing.SetGlobalTracer(tracer)

	ctx := context.TODO()
	span := opentracing.StartSpan("demo")
	ctx = opentracing.ContextWithSpan(ctx, span)
	busyness(ctx, 5)
}

```

![jaeger demo](/pics/jaeger-demo.png)